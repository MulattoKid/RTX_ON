#version 460
#extension GL_NV_ray_tracing : require
#extension GL_GOOGLE_include_directive : require

#include "Defines.glsl"
#include "Camera.glsl"
#include "DataLayouts.glsl"
#include "Sample.glsl"
#include "Sphere.glsl"

#define ONE_OVER_PI 0.3183098861837907f

// Other
#define SUB_SAMPLE_ISECT_POINT 0

// Sample points to use
#define REGULAR_SAMPLES 0
#define BLUE_NOISE 1
#define BLUE_NOISE_ANIMATE 0
#define GOLDEN_RATIO 0
#define FIBONACCI_SPIRAL 0

// Sample method
#define SAMPLE_UNIFORM 0
#define SAMPLE_COSINE 1

/*#if REGULAR_SAMPLES
struct SamplePoint =
{
};
#else
	#if BLUE_NOISE_ANIMATION
		SamplePoint samplePoints[3][64] =
		{
		};
	#else
		SamplePoint samplePoints[64] =
		{
		#if BLUE_NOISE
		#elif GOLDEN_RATIO
		#elif FIBONACCI_SPIRAL
		#endif
		};
	#endif
#endif*/

#if REGULAR_SAMPLES
#else
struct SamplePoint
{
	float u0;
	float u1;
};
#if BLUE_NOISE_ANIMATE
SamplePoint samplePoints[3][64] =
{
    {
        {0.421875, 0.158203},
        {0.939453, 0.038086},
        {0.196289, 0.688477},
        {0.311523, 0.430664},
        {0.710938, 0.887695},
        {0.492188, 0.652344},
        {0.944336, 0.782227},
        {0.914062, 0.456055},
        {0.750977, 0.460938},
        {0.188477, 0.972656},
        {0.894531, 0.244141},
        {0.647461, 0.277344},
        {0.525391, 0.375000},
        {0.161133, 0.228516},
        {0.364258, 0.816406},
        {0.567383, 0.010742},
        {0.098633, 0.427734},
        {0.099609, 0.094727},
        {0.311523, 0.274414},
        {0.819336, 0.600586},
        {0.000977, 0.584961},
        {0.774414, 0.173828},
        {0.142578, 0.830078},
        {0.797852, 0.764648},
        {0.690430, 0.583008},
        {0.261719, 0.561523},
        {0.422852, 0.030273},
        {0.613281, 0.740234},
        {0.038086, 0.900391},
        {0.800781, 0.028320},
        {0.523438, 0.853516},
        {0.640625, 0.145508},
        {0.267578, 0.126953},
        {0.106445, 0.540039},
        {0.057617, 0.693359},
        {0.306641, 0.002930},
        {0.351562, 0.684570},
        {0.432617, 0.496094},
        {0.908203, 0.665039},
        {0.033203, 0.204102},
        {0.432617, 0.301758},
        {0.829102, 0.355469},
        {0.875000, 0.894531},
        {0.640625, 0.479492},
        {0.266602, 0.889648},
        {0.463867, 0.949219},
        {0.183594, 0.342773},
        {0.564453, 0.555664},
        {0.524414, 0.125977},
        {0.912109, 0.557617},
        {0.499023, 0.755859},
        {0.007812, 0.342773},
        {0.986328, 0.123047},
        {0.708008, 0.727539},
        {0.616211, 0.919922},
        {0.876953, 0.141602},
        {0.542969, 0.276367},
        {0.041992, 0.798828},
        {0.181641, 0.117188},
        {0.005859, 0.483398},
        {0.537109, 0.466797},
        {0.237305, 0.784180},
        {0.100586, 0.308594},
        {0.589844, 0.659180},
    },
    {
        {0.267578, 0.126953},
        {0.106445, 0.540039},
        {0.057617, 0.693359},
        {0.306641, 0.002930},
        {0.351562, 0.684570},
        {0.432617, 0.496094},
        {0.908203, 0.665039},
        {0.033203, 0.204102},
        {0.432617, 0.301758},
        {0.829102, 0.355469},
        {0.875000, 0.894531},
        {0.640625, 0.479492},
        {0.266602, 0.889648},
        {0.463867, 0.949219},
        {0.183594, 0.342773},
        {0.564453, 0.555664},
        {0.524414, 0.125977},
        {0.912109, 0.557617},
        {0.499023, 0.755859},
        {0.007812, 0.342773},
        {0.986328, 0.123047},
        {0.708008, 0.727539},
        {0.616211, 0.919922},
        {0.876953, 0.141602},
        {0.542969, 0.276367},
        {0.041992, 0.798828},
        {0.181641, 0.117188},
        {0.005859, 0.483398},
        {0.537109, 0.466797},
        {0.237305, 0.784180},
        {0.100586, 0.308594},
        {0.589844, 0.659180},
        {0.715820, 0.057617},
        {0.671875, 0.203125},
        {0.206055, 0.633789},
        {0.291992, 0.553711},
        {0.989258, 0.998047},
        {0.299805, 0.260742},
        {0.333984, 0.415039},
        {0.768555, 0.597656},
        {0.692383, 0.339844},
        {0.138672, 0.975586},
        {0.405273, 0.166992},
        {0.449219, 0.617188},
        {0.837891, 0.772461},
        {0.756836, 0.883789},
        {0.234375, 0.440430},
        {0.816406, 0.473633},
        {0.913086, 0.254883},
        {0.481445, 0.393555},
        {0.584961, 0.026367},
        {0.789062, 0.240234},
        {0.982422, 0.898438},
        {0.623047, 0.790039},
        {0.376953, 0.892578},
        {0.913086, 0.407227},
        {0.955078, 0.765625},
        {0.875000, 0.006836},
        {0.432617, 0.067383},
        {0.136719, 0.826172},
        {0.149414, 0.205078},
        {0.082031, 0.109375},
        {0.540039, 0.859375},
        {0.737305, 0.445312},
    },
    {
        {0.671875, 0.203125},
        {0.206055, 0.633789},
        {0.291992, 0.553711},
        {0.989258, 0.998047},
        {0.299805, 0.260742},
        {0.333984, 0.415039},
        {0.768555, 0.597656},
        {0.692383, 0.339844},
        {0.138672, 0.975586},
        {0.405273, 0.166992},
        {0.449219, 0.617188},
        {0.837891, 0.772461},
        {0.756836, 0.883789},
        {0.234375, 0.440430},
        {0.816406, 0.473633},
        {0.913086, 0.254883},
        {0.481445, 0.393555},
        {0.584961, 0.026367},
        {0.789062, 0.240234},
        {0.982422, 0.898438},
        {0.623047, 0.790039},
        {0.376953, 0.892578},
        {0.913086, 0.407227},
        {0.955078, 0.765625},
        {0.875000, 0.006836},
        {0.432617, 0.067383},
        {0.136719, 0.826172},
        {0.149414, 0.205078},
        {0.082031, 0.109375},
        {0.540039, 0.859375},
        {0.737305, 0.445312},
        {0.642578, 0.401367},
        {0.292969, 0.073242},
        {0.016602, 0.562500},
        {0.714844, 0.050781},
        {0.033203, 0.381836},
        {0.257812, 0.802734},
        {0.080078, 0.665039},
        {0.531250, 0.164062},
        {0.403320, 0.762695},
        {0.709961, 0.698242},
        {0.544922, 0.543945},
        {0.872070, 0.150391},
        {0.143555, 0.339844},
        {0.555664, 0.673828},
        {0.252930, 0.963867},
        {0.447266, 0.960938},
        {0.896484, 0.667969},
        {0.004883, 0.470703},
        {0.025391, 0.267578},
        {0.886719, 0.549805},
        {0.564453, 0.313477},
        {0.143555, 0.502930},
        {0.410156, 0.283203},
        {0.772461, 0.128906},
        {0.658203, 0.932617},
        {0.430664, 0.520508},
        {0.332031, 0.653320},
        {0.802734, 0.364258},
        {0.655273, 0.509766},
        {0.266602, 0.337891},
        {0.250000, 0.163086},
        {0.496094, 0.796875},
        {0.355469, 0.000000},
    },
};
#else
SamplePoint samplePoints[64] =
{
#if BLUE_NOISE
    {0.869141, 0.657227},
    {0.379883, 0.838867},
    {0.349609, 0.327148},
    {0.610352, 0.965820},
    {0.652344, 0.242188},
    {0.127930, 0.654297},
    {0.803711, 0.305664},
    {0.863281, 0.047852},
    {0.058594, 0.240234},
    {0.355469, 0.554688},
    {0.617188, 0.684570},
    {0.385742, 0.095703},
    {0.196289, 0.835938},
    {0.192383, 0.029297},
    {0.538086, 0.458008},
    {0.935547, 0.457031},
    {0.162109, 0.416992},
    {0.933594, 0.852539},
    {0.739258, 0.434570},
    {0.720703, 0.054688},
    {0.245117, 0.196289},
    {0.482422, 0.198242},
    {0.008789, 0.044922},
    {0.333008, 0.684570},
    {0.783203, 0.798828},
    {0.340820, 0.972656},
    {0.775391, 0.177734},
    {0.091797, 0.927734},
    {0.504883, 0.589844},
    {0.561523, 0.818359},
    {0.972656, 0.325195},
    {0.530273, 0.342773},
    {0.086914, 0.528320},
    {0.898438, 0.186523},
    {0.584961, 0.099609},
    {0.437500, 0.466797},
    {0.744141, 0.627930},
    {0.464844, 0.931641},
    {0.068359, 0.747070},
    {0.318359, 0.450195},
    {0.708008, 0.900391},
    {0.419922, 0.731445},
    {0.165039, 0.289062},
    {0.090820, 0.128906},
    {0.194336, 0.547852},
    {0.053711, 0.401367},
    {0.526367, 0.729492},
    {0.657227, 0.356445},
    {0.370117, 0.214844},
    {0.623047, 0.526367},
    {0.948242, 0.963867},
    {0.990234, 0.663086},
    {0.794922, 0.966797},
    {0.282227, 0.887695},
    {0.858398, 0.532227},
    {0.917969, 0.765625},
    {0.674805, 0.784180},
    {0.842773, 0.416016},
    {0.468750, 0.059570},
    {0.435547, 0.374023},
    {0.231445, 0.725586},
    {0.951172, 0.585938},
    {0.228516, 0.346680},
    {0.292969, 0.080078}
#elif GOLDEN_RATIO
	{0.253906, 0.069336},
    {0.008789, 0.639648},
    {0.763672, 0.208984},
    {0.518555, 0.779297},
    {0.273438, 0.348633},
    {0.028320, 0.918945},
    {0.783203, 0.488281},
    {0.538086, 0.058594},
    {0.292969, 0.627930},
    {0.047852, 0.198242},
    {0.802734, 0.767578},
    {0.557617, 0.337891},
    {0.312500, 0.907227},
    {0.067383, 0.477539},
    {0.822266, 0.046875},
    {0.577148, 0.617188},
    {0.332031, 0.186523},
    {0.086914, 0.756836},
    {0.841797, 0.326172},
    {0.596680, 0.896484},
    {0.351562, 0.465820},
    {0.106445, 0.036133},
    {0.861328, 0.605469},
    {0.616211, 0.175781},
    {0.371094, 0.745117},
    {0.125977, 0.315430},
    {0.880859, 0.884766},
    {0.635742, 0.455078},
    {0.390625, 0.024414},
    {0.145508, 0.594727},
    {0.900391, 0.165039},
    {0.655273, 0.734375},
    {0.410156, 0.304688},
    {0.165039, 0.874023},
    {0.919922, 0.444336},
    {0.674805, 0.013672},
    {0.429688, 0.583984},
    {0.184570, 0.153320},
    {0.939453, 0.723633},
    {0.694336, 0.292969},
    {0.449219, 0.863281},
    {0.204102, 0.432617},
    {0.958984, 0.002930},
    {0.713867, 0.572266},
    {0.468750, 0.142578},
    {0.223633, 0.711914},
    {0.978516, 0.282227},
    {0.733398, 0.851562},
    {0.488281, 0.421875},
    {0.243164, 0.991211},
    {0.998047, 0.561523},
    {0.752930, 0.130859},
    {0.507812, 0.701172},
    {0.262695, 0.270508},
    {0.017578, 0.840820},
    {0.772461, 0.410156},
    {0.527344, 0.980469},
    {0.282227, 0.549805},
    {0.037109, 0.120117},
    {0.791992, 0.689453},
    {0.546875, 0.259766},
    {0.301758, 0.830078},
    {0.056641, 0.399414},
    {0.811523, 0.969727}
#elif FIBONACCI_SPIRAL //0=theta, 1=phi
	{0.088853, 2.399963},
    {0.154306, 4.799926},
    {0.199744, 7.199889},
    {0.236984, 9.599853},
    {0.269456, 11.999816},
    {0.298726, 14.399778},
    {0.325667, 16.799742},
    {0.350824, 19.199705},
    {0.374564, 21.599669},
    {0.397148, 23.999632},
    {0.418771, 26.399595},
    {0.439582, 28.799557},
    {0.459699, 31.199520},
    {0.479216, 33.599483},
    {0.498213, 35.999447},
    {0.516752, 38.399410},
    {0.534891, 40.799374},
    {0.552676, 43.199337},
    {0.570149, 45.599300},
    {0.587346, 47.999264},
    {0.604299, 50.399227},
    {0.621037, 52.799191},
    {0.637585, 55.199154},
    {0.653969, 57.599113},
    {0.670209, 59.999077},
    {0.686326, 62.399040},
    {0.702339, 64.799004},
    {0.718268, 67.198967},
    {0.734127, 69.598930},
    {0.749935, 71.998894},
    {0.765708, 74.398857},
    {0.781461, 76.798820},
    {0.797210, 79.198784},
    {0.812971, 81.598747},
    {0.828760, 83.998711},
    {0.844591, 86.398674},
    {0.860483, 88.798637},
    {0.876452, 91.198601},
    {0.892515, 93.598564},
    {0.908691, 95.998528},
    {0.925000, 98.398491},
    {0.941463, 100.798454},
    {0.958103, 103.198418},
    {0.974945, 105.598381},
    {0.992016, 107.998344},
    {1.009347, 110.398308},
    {1.026971, 112.798271},
    {1.044927, 115.198227},
    {1.063261, 117.598190},
    {1.082021, 119.998154},
    {1.101269, 122.398117},
    {1.121075, 124.798080},
    {1.141526, 127.198044},
    {1.162727, 129.598007},
    {1.184810, 131.997971},
    {1.207944, 134.397934},
    {1.232354, 136.797897},
    {1.258348, 139.197861},
    {1.286370, 141.597824},
    {1.317101, 143.997787},
    {1.351690, 146.397751},
    {1.392380, 148.797714},
    {1.444973, 151.197678},
    {1.570796, 153.597641}
#endif
};
#endif
#endif

layout(set = 0, binding = RT1_ACCELERATION_STRUCTURE_NV_BINDING_LOCATION) uniform accelerationStructureNV scene;
layout(set = 0, binding = RT1_POSITION_IMAGE_BINDING_LOCATION) uniform sampler2D positionImage;
layout(set = 0, binding = RT1_NORMAL_IMAGE_BINDING_LOCATION) uniform sampler2D normalImage;
layout(set = 0, binding = RT1_AO_IMAGE_BINDING_LOCATION, rgba32f) uniform image2D aoImage;
layout(set = 0, binding = RT1_CURRENT_FRAME_BINDING_LOCATION, std140) uniform currentFrameVariableBuffer
{
	uint currentFrame;
};

layout(location = PRIMARY_PAYLOAD_LOCATION) rayPayloadNV ShadowRayPayload primaryPayload;

float VisibilityFunction(float dist)
{
	// y = n^(-x)
#if SAMPLE_UNIFORM
	return pow(2.0f, -dist);
#elif SAMPLE_COSINE
	return pow(32.0f, -dist);
#endif
}

void main()
{
	const uint rayFlags = gl_RayFlagsNoneNV;
    const uint cullMask = 0xFF;
    const uint sbtRecordStride = 0;
    const float tMin = 0.0f;
    const float tMax = 100.0f;
	
	// Intersection data
	vec4 positionFractionVisible = texture(positionImage, vec2(gl_LaunchIDNV.xy) / vec2(gl_LaunchSizeNV.xy));
	vec3 isectPoint = positionFractionVisible.xyz;
	vec3 isectNormal = texture(normalImage, vec2(gl_LaunchIDNV.xy) / vec2(gl_LaunchSizeNV.xy)).xyz;
	// Early exit:
	// 	Either if position is vec3(0.0f), indicating a special case
	// 	Or if one of the lights are visible from the point
	if (isectPoint == vec3(0.0f) || positionFractionVisible.w > 0.0f)
	{
		imageStore(aoImage, ivec2(gl_LaunchIDNV.xy), vec4(0.0f));
		return;
	}

#if SUB_SAMPLE_ISECT_POINT
	// Calculate the two directions that will be used to "sub-sample" the intersection point
	// Runs the risk of going too far and ending up within some other geometry...
	// 1) Find equation of plane: https://math.stackexchange.com/questions/753113/how-to-find-an-equation-of-the-plane-given-its-normal-vector-and-a-point-on-the?newreg=c41a1becdbb54022a59483dbb1068fea
	vec3 abc = isectNormal;
	float d = dot(isectPoint, isectNormal);
	// 2) Find the largest plane-equation coefficient
	int abcIndex = -1;
	int abcIndexDirOne = -1;
	int abcIndexDirTwo = -1;
	// Get the first that is not 0.0f
	if (abc.x != 0.0f)
	{
		abcIndex = 0;
		abcIndexDirOne = 1;
		abcIndexDirTwo = 2;
	}
	else if (abc.y != 0.0f)
	{
		abcIndex = 1;
		abcIndexDirOne = 0;
		abcIndexDirTwo = 2;
	}
	else
	{
		abcIndex = 2;
		abcIndexDirOne = 0;
		abcIndexDirTwo = 1;
	}
	// 3) Find the two directions: https://math.stackexchange.com/questions/2563909/find-points-on-a-plane
	vec3 pointDirOne = isectPoint;
	pointDirOne[abcIndexDirOne] -= 1.0f;
	float phi = -abc[abcIndexDirOne] / abc[abcIndex];
	pointDirOne[abcIndex] += phi;
	vec3 dirOne = normalize(pointDirOne - isectPoint);
	// dirTwo can be found more efficiantely by taking the cross-product of dirOne and the normal
	vec3 dirTwo = cross(dirOne, isectNormal);
	
	// Constants for sub-sampling occlusion ray's origin
	const float maxOffset = 0.001f;
	const float minOffset = -maxOffset;
#endif

	// AO calculations
	const int numOcclusionSteps = 7;
	const int totalOcclusionSamples = numOcclusionSteps * numOcclusionSteps;
	float occlusion = 0.0f;
	for (int y = 0; y <= numOcclusionSteps; y++)
	{
		for (int x = 0; x <= numOcclusionSteps; x++)
		{
			float xFrac = float(x) / float(numOcclusionSteps);
			float yFrac = float(y) / float(numOcclusionSteps);

#if SUB_SAMPLE_ISECT_POINT
			vec3 occlusionRayOrigin = isectPoint + (isectNormal * 0.001f) +
									  	(dirOne * mix(minOffset, maxOffset, xFrac)) +
									   	(dirTwo * mix(minOffset, maxOffset, yFrac));
#else
			vec3 occlusionRayOrigin = isectPoint + (isectNormal * 0.001f);
#endif
			
			float idx = y * numOcclusionSteps + x;
			int idxI = int(idx);
#if SAMPLE_COSINE
#if REGULAR_SAMPLES
			vec3 occlusionRayDir = SampleHemisphereCosine(isectNormal, vec2(idx / float(numOcclusionSteps), idx / float(totalOcclusionSamples)));
#elif FIBONACCI_SPIRAL
			vec3 occlusionRayDir = SampleHemisphereFibonacciSpiral(isectNormal, vec2(samplePoints[idxI].u0, samplePoints[idxI].u1));
#elif BLUE_NOISE_ANIMATE
			uint blueNoiseFrameIdx = currentFrame % 3;
			vec3 occlusionRayDir = SampleHemisphereCosine(isectNormal, vec2(samplePoints[blueNoiseFrameIdx][idxI].u0, samplePoints[blueNoiseFrameIdx][idxI].u1));
#else // BLUE_NOISE or GOLDEN_RATIO
			vec3 occlusionRayDir = SampleHemisphereCosine(isectNormal, vec2(samplePoints[idxI].u0, samplePoints[idxI].u1));
#endif
#else //SAMPLE_UNIFORM
#if REGULAR_SAMPLES
			vec3 occlusionRayDir = SampleHemisphere(isectNormal, vec2(idx / float(numOcclusionSteps), idx / float(totalOcclusionSamples)));
#elif FIBONACCI_SPIRAL
			vec3 occlusionRayDir = SampleHemisphereFibonacciSpiral(isectNormal, vec2(samplePoints[idxI].u0, samplePoints[idxI].u1));
#elif BLUE_NOISE_ANIMATE
			uint blueNoiseFrameIdx = currentFrame % 3;
			vec3 occlusionRayDir = SampleHemisphere(isectNormal, vec2(samplePoints[blueNoiseFrameIdx][idxI].u0, samplePoints[blueNoiseFrameIdx][idxI].u1));
#else // BLUE_NOISE or GOLDEN_RATIO
			vec3 occlusionRayDir = SampleHemisphere(isectNormal, vec2(samplePoints[idxI].u0, samplePoints[idxI].u1));
#endif
#endif

			traceNV(scene, rayFlags, cullMask, RT1_PRIMARY_CHIT_IDX, sbtRecordStride, RT1_PRIMARY_MISS_IDX, occlusionRayOrigin, tMin, occlusionRayDir, tMax, PRIMARY_PAYLOAD_LOCATION);
						
			// Check for intersection with geometry
			if (primaryPayload.hitDist.x >= 0.0f)
			{

#if SAMPLE_COSINE
#if FIBONACCI_SPIRAL // Does not use cosine sampling
				occlusion += VisibilityFunction(primaryPayload.hitDist.x) * dot(isectNormal, occlusionRayDir);
#else
				occlusion += VisibilityFunction(primaryPayload.hitDist.x);
#endif
#elif SAMPLE_UNIFORM
				occlusion += VisibilityFunction(primaryPayload.hitDist.x) * dot(isectNormal, occlusionRayDir);
#endif
			}
		}
	}
	occlusion /= float(totalOcclusionSamples) * ONE_OVER_PI;
	// For safety due to rounding-error: occlusion cannot be more than 1.0f
	occlusion = min(occlusion, 1.0f);
	
	imageStore(aoImage, ivec2(gl_LaunchIDNV.xy), vec4(occlusion, 0.0f, 0.0f, 0.0f));
}
