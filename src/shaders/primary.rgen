#version 460
#extension GL_NV_ray_tracing : require
#extension GL_GOOGLE_include_directive : require

#define AO_CONE 0
#define AO_HEMISPHERE_HARD 1
#define HARD_SHADOWS 0

#include "Camera.glsl"
#include "DataLayouts.glsl"
#include "Defines.glsl"
#include "Sample.glsl"
#include "Sphere.glsl"

layout(set = 0, binding = ACCELERATION_STRUCTURE_NV_BINDING_LOCATION) uniform accelerationStructureNV scene;
layout(set = 0, binding = RESULT_IMAGE_BINDING_LOCATION, rgba8) uniform image2D resultImage;
layout(set = 0, binding = CAMERA_BUFFER_BINDING_LOCATION, std140) uniform cameraBuffer
{
	Camera camera;
};
layout(set = 0, binding = LIGHTS_BUFFER_BINDING_LOCATION, std140) readonly buffer lightBuffer
{
	SphericalLightSource lights[];
};
layout(set = 0, binding = OTHER_DATA_BUFFER_BINDING_LOCATION, std140) uniform otherDataBuffer
{
	OtherData otherData;
};

layout(location = PRIMARY_PAYLOAD_LOCATION) rayPayloadNV PrimaryRayPayload primaryPayload;
layout(location = SECONDARY_PAYLOAD_LOCATION) rayPayloadNV ShadowRayPayload secondaryPayload;

void main()
{
	const uint rayFlags = gl_RayFlagsNoneNV;
    const uint cullMask = 0xFF;
    const uint sbtRecordStride = 0;
    const float tMin = 0.0f;
    const float tMax = 1000.0f;
	
	// Trace primary ray
	Ray ray = GenerateRayFromCamera(camera);
    traceNV(scene, rayFlags, cullMask, PRIMARY_CHIT_IDX, sbtRecordStride, PRIMARY_MISS_IDX, ray.origin, tMin, ray.dir, tMax, PRIMARY_PAYLOAD_LOCATION);
    
    // Early exit - no geometry hit
	if (primaryPayload.normalAndHitDistance.w < 0.0f)
	{
		//Background color: blue sky-ish
		const float y = gl_LaunchIDNV.y / 1024.0f;
		const float red = mix(0.0f, 0.7f, y);
		const float green = mix(0.65f, 0.9f, y);
		imageStore(resultImage, ivec2(gl_LaunchIDNV.xy), vec4(0.8f, green, red, 1.0f));
		return;
	}
	
	// Intersection data
	vec3 isectNormal = primaryPayload.normalAndHitDistance.xyz;
	vec3 isectPoint = ray.origin + (ray.dir * primaryPayload.normalAndHitDistance.w);
	
#if AO_CONE	
	int numOcclusionSteps = 6;
	int totalOcclusionSamples = numOcclusionSteps * numOcclusionSteps;
	int totalOcclusionSamplesPerLight = totalOcclusionSamples / otherData.numSphericalLightSources;
	int numOcclusionStepsPerLighti = int(sqrt(totalOcclusionSamplesPerLight));
	int numOcclusionStepsPerLightj = numOcclusionStepsPerLighti;
	int totalOcclusionSamplesPerLightGoingUp = numOcclusionStepsPerLighti * numOcclusionStepsPerLightj;
	int remainingSamplesPerLight = totalOcclusionSamplesPerLight - totalOcclusionSamplesPerLightGoingUp;
	numOcclusionStepsPerLighti += remainingSamplesPerLight / numOcclusionStepsPerLighti;
	vec3 color = vec3(0.0f);
	for (int l = 0; l < otherData.numSphericalLightSources; l++)
	{
		// Extract light data
		vec3 lightCenter = lights[l].centerAndRadius.xyz;
		float lightRadius = lights[l].centerAndRadius.w;
		vec3 lightEmittance = lights[l].emittance.rgb;
		
		// Sample a cone of directions given the vector from the isect point to the light and its radius
		vec3 isectPointToLightCenter = lightCenter - isectPoint;
		vec3 isectPointToLightCenterDir = normalize(isectPointToLightCenter);
		float isectPointToLightCenterDist = length(isectPointToLightCenter);
		float tangentDist = sqrt((isectPointToLightCenterDist * isectPointToLightCenterDist) - (lightRadius * lightRadius));
		float cosThetaIsectPointLightTangent = tangentDist / isectPointToLightCenterDist;
		float conePdf = ConePdf(cosThetaIsectPointLightTangent);
		float lightContr = 0.0f;
		for (int i = 0; i <= numOcclusionStepsPerLighti; i++)
		{
			for (int j = 0; j <= numOcclusionStepsPerLightj; j++)
			{
				// Sample occlusion ray direction and trace
				vec3 occlusionRayDir = SampleCone(isectPointToLightCenterDir, vec2(float(i) / float(numOcclusionSteps), float(j) / float(numOcclusionSteps)), cosThetaIsectPointLightTangent);
				Ray occlusionRay = GenerateRay(isectPoint + (isectNormal * 0.001f), occlusionRayDir);
				traceNV(scene, rayFlags, cullMask, SECONDARY_CHIT_IDX, sbtRecordStride, SECONDARY_MISS_IDX, occlusionRay.origin, tMin, occlusionRay.dir, tMax, SECONDARY_PAYLOAD_LOCATION);
				
				// Intersect spherical light
				float lightDist = SphereIntersect(lightCenter, lightRadius, occlusionRay.origin, occlusionRay.dir, tMin, tMax);
				
				// Check for intersection with geometry before an intersection with the light
				// 1) Did intersect the light
				// 2) Either didn't hit some geometry or the distance to the isect is further
				//    than the distance to the isect on the light
				if ((lightDist >= 0.0f) && (secondaryPayload.hitDist.x < 0.0f || secondaryPayload.hitDist.x >= lightDist))
				{
					lightContr += dot(isectNormal, occlusionRay.dir);
				}
			}
		}
		
		// Add light's contribution
		color += lightEmittance * lightContr / conePdf;
	}
	color *= primaryPayload.materialColor.rgb;
	color /= numOcclusionStepsPerLighti * numOcclusionStepsPerLightj * otherData.numSphericalLightSources;
	
	// Store
    imageStore(resultImage, ivec2(gl_LaunchIDNV.xy), vec4(color, 1.0f));
    
#elif AO_HEMISPHERE_HARD
	// Treats spherical light sources as point-lights, but use radius
	// when checking the intersection distance
	vec3 color = vec3(0.0f);
	for (int l = 0; l < otherData.numSphericalLightSources; l++)
	{
		vec3 lightPos = lights[l].centerAndRadius.xyz;
		float lightRadius = lights[l].centerAndRadius.w;
		vec3 lightEmittance = lights[l].emittance.rgb;
		// Intersection-Light data
		vec3 isectPointToLight = lightPos - isectPoint;
		vec3 isectPointToLightDir = normalize(isectPointToLight);
		float isectPointToLightDist = length(isectPointToLight) - lightRadius;

		// Trace shadow rays
		Ray shadowRay = GenerateRay(isectPoint + (isectNormal * 0.001f), isectPointToLightDir);
		traceNV(scene, rayFlags, cullMask, SECONDARY_CHIT_IDX, sbtRecordStride, SECONDARY_MISS_IDX, shadowRay.origin, tMin, shadowRay.dir, tMax, SECONDARY_PAYLOAD_LOCATION);
		
		// Check for geometry between intersection point and light
		if (secondaryPayload.hitDist.x >= 0.0f && secondaryPayload.hitDist.x < isectPointToLightDist)
		{
		 	continue;
		}
			
		// Calculate light
		// Multiply with HemispherePdf as we only take one sample but this SINGLE sample represents the entire
		// integration interval -> an infitnite number of samples are "in theory" taken.
		color += lightEmittance * dot(isectNormal, isectPointToLightDir) * HemispherePdf();
	}
	color *= primaryPayload.materialColor.rgb;
	color /= otherData.numSphericalLightSources;

	int numOcclusionSteps = 6;
	int totalOcclusionSamples = numOcclusionSteps * numOcclusionSteps;
	// Sample hemisphere of directions given the normal at the intersection point
	int numAO = 0;
	for (int i = 0; i <= numOcclusionSteps; i++)
	{
		for (int j = 0; j <= numOcclusionSteps; j++)
		{
			// Sample occlusion ray direction and trace
			vec3 occlusionRayDir = SampleHemisphere(isectNormal, vec2(float(i) / float(numOcclusionSteps), float(j) / float(numOcclusionSteps)));
			Ray occlusionRay = GenerateRay(isectPoint + (isectNormal * 0.001f), occlusionRayDir);
			traceNV(scene, rayFlags, cullMask, SECONDARY_CHIT_IDX, sbtRecordStride, SECONDARY_MISS_IDX, occlusionRay.origin, tMin, occlusionRay.dir, tMax, SECONDARY_PAYLOAD_LOCATION);
				
			// Check for intersection with geometry
			if (secondaryPayload.hitDist.x >= 0.0f)
			{
				numAO++;
			}
		}
	}
	color *= float(totalOcclusionSamples - numAO) / float(totalOcclusionSamples);
	
	// Store
    imageStore(resultImage, ivec2(gl_LaunchIDNV.xy), vec4(color, 1.0f));
	
#elif HARD_SHADOWS
	// Treats spherical light sources as point-lights, but use radius
	// when checking the intersection distance
	vec3 color = vec3(0.0f);
	for (int l = 0; l < otherData.numSphericalLightSources; l++)
	{
		vec3 lightPos = lights[l].centerAndRadius.xyz;
		float lightRadius = lights[l].centerAndRadius.w;
		vec3 lightEmittance = lights[l].emittance.rgb;
		// Intersection-Light data
		vec3 isectPointToLight = lightPos - isectPoint;
		vec3 isectPointToLightDir = normalize(isectPointToLight);
		float isectPointToLightDist = length(isectPointToLight) - lightRadius;

		// Trace shadow rays
		Ray shadowRay = GenerateRay(isectPoint + (isectNormal * 0.001f), isectPointToLightDir);
		traceNV(scene, rayFlags, cullMask, SECONDARY_CHIT_IDX, sbtRecordStride, SECONDARY_MISS_IDX, shadowRay.origin, tMin, shadowRay.dir, tMax, SECONDARY_PAYLOAD_LOCATION);
		
		// Check for geometry between intersection point and light
		if (secondaryPayload.hitDist.x >= 0.0f && secondaryPayload.hitDist.x < isectPointToLightDist)
		{
		 	continue;
		}
			
		// Calculate light
		// Multiply with HemispherePdf as we only take one sample but this SINGLE sample represents the entire
		// integration interval -> an infitnite number of samples are "in theory" taken.
		color += lightEmittance * dot(isectNormal, isectPointToLightDir) * HemispherePdf();
	}
	color *= primaryPayload.materialColor.rgb;
	color /= otherData.numSphericalLightSources;
	
	// Store
    imageStore(resultImage, ivec2(gl_LaunchIDNV.xy), vec4(color, 1.0f));

#endif
}



















