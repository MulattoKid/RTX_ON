#version 460
#extension GL_NV_ray_tracing : require
#extension GL_GOOGLE_include_directive : require

#include "Camera.glsl"
#include "Defines.glsl"
#include "Random.glsl"
#include "Sample.glsl"
#include "Sphere.glsl"

layout(set = 0, binding = ACCELERATION_STRUCTURE_NV_BINDING_LOCATION) uniform accelerationStructureNV scene;
layout(set = 0, binding = RESULT_IMAGE_BINDING_LOCATION, rgba8) uniform image2D resultImage;
layout(set = 0, binding = CAMERA_BUFFER_BINDING_LOCATION, std140) uniform cameraBuffer
{
	Camera camera;
};
layout(set = 0, binding = RANDOM_BUFFER_BINDING_LOCATION, std140) uniform randomBuffer
{
	vec2 random;
};

layout(location = PRIMARY_PAYLOAD_LOCATION) rayPayloadNV PrimaryRayPayload primaryPayload;
layout(location = SECONDARY_PAYLOAD_LOCATION) rayPayloadNV ShadowRayPayload secondaryPayload;

void main()
{
	const uint rayFlags = gl_RayFlagsNoneNV;
    const uint cullMask = 0xFF;
    const uint sbtRecordStride = 0;
    const float tMin = 0.0f;
    const float tMax = 1000.0f;
	
	// Trace primary ray
	Ray ray = GenerateRayFromCamera(camera);
    traceNV(scene, rayFlags, cullMask, PRIMARY_CHIT_IDX, sbtRecordStride, PRIMARY_MISS_IDX, ray.origin, tMin, ray.dir, tMax, PRIMARY_PAYLOAD_LOCATION);
    
    // Early exit
	if (primaryPayload.normalAndHitDistance.w < 0.0f)
	{
		//Background color: blue sky-ish
		const float y = gl_LaunchIDNV.y / 1024.0f;
		const float red = mix(0.0f, 0.7f, y);
		const float green = mix(0.65f, 0.9f, y);
		imageStore(resultImage, ivec2(gl_LaunchIDNV.xy), vec4(0.8f, green, red, 1.0f));
		return;
	}
	
	// Intersection data
	vec3 isectNormal = primaryPayload.normalAndHitDistance.xyz;
	vec3 isectPoint = ray.origin + (ray.dir * primaryPayload.normalAndHitDistance.w);
	
	// Advanced light data
	vec3 lightCenter = vec3(0.0f, 20.0f, 0.0f);
	float lightRadius = 5.0f;
	vec3 lightColor = vec3(3.0f, 3.0f, 3.0f);
	
	// Sample random directions around hemisphere
	/*const int numOcclusionRays = 100;
	int numMissOrOccluded = 0;
	for (int i = 0; i < numOcclusionRays; i++)
	{
		// Sample occlusion ray direction and trace
		vec3 occlusionRayDir = SampleNormalHemisphere(isectNormal, Random2D(random, i, numOcclusionRays, gl_LaunchIDNV.xy / gl_LaunchSizeNV.xy));
		Ray occlusionRay = GenerateRay(isectPoint + (isectNormal * 0.001f), occlusionRayDir);
		traceNV(scene, rayFlags, cullMask, SECONDARY_CHIT_IDX, sbtRecordStride, SECONDARY_MISS_IDX, occlusionRay.origin, tMin, occlusionRay.dir, tMax, SECONDARY_PAYLOAD_LOCATION);
		
		// Intersect spherical light
		float lightDist = SphereIntersect(lightCenter, lightRadius, occlusionRay.origin, occlusionRay.dir, tMin, tMax);
		
		// Check for intersection with geometry before an intersection with the light
		// 1) Didn't intersect the light
		// 2) Hit some geometry and the distance to the isect is closer than the distance to the isect on the light
		if ((lightDist < 0.0f) || (secondaryPayload.hitDist.x >= 0.0f && secondaryPayload.hitDist.x < lightDist))
		{
			numMissOrOccluded++;
		}
	}
	vec3 color = vec3(float((numOcclusionRays - numMissOrOccluded)) / float(numOcclusionRays));*/
	
	// Sample n pre-determined points around the hemisphere
	/*const int numOcclusionSteps = 10;
	int totalOcclusionSamples = int(pow(numOcclusionSteps + 1, 2));
	int numMissOrOccluded = 0;
	for (int phi = 0; phi <= numOcclusionSteps; phi++)
	{
		for (int theta = 0; theta <= numOcclusionSteps; theta++)
		{
			// Sample occlusion ray direction and trace
			vec3 occlusionRayDir = SampleNormalHemisphere(isectNormal, vec2(float(phi) / float(numOcclusionSteps), float(theta) / float(numOcclusionSteps)));
			//occlusionRayDir = SampleNormalHemisphere(isectNormal, vec2(0.25f, 1.0f));
			Ray occlusionRay = GenerateRay(isectPoint + (isectNormal * 0.001f), occlusionRayDir);
			traceNV(scene, rayFlags, cullMask, SECONDARY_CHIT_IDX, sbtRecordStride, SECONDARY_MISS_IDX, occlusionRay.origin, tMin, occlusionRay.dir, tMax, SECONDARY_PAYLOAD_LOCATION);
			
			// Intersect spherical light
			float lightDist = SphereIntersect(lightCenter, lightRadius, occlusionRay.origin, occlusionRay.dir, tMin, tMax);
			
			// Check for intersection with geometry before an intersection with the light
			// 1) Didn't intersect the light
			// 2) Hit some geometry and the distance to the isect is closer than the distance to the isect on the light
			if ((lightDist < 0.0f) || (secondaryPayload.hitDist.x >= 0.0f && secondaryPayload.hitDist.x < lightDist))
			{
				numMissOrOccluded++;
			}
		}
	}
	vec3 color = vec3(float((numOcclusionSteps * numOcclusionSteps) - numMissOrOccluded) / float(numOcclusionSteps * numOcclusionSteps));
	//color = vec3(numMissOrOccluded / (numOcclusionSteps * numOcclusionSteps));
	color = vec3(numMissOrOccluded);
	color = vec3(totalOcclusionSamples - numMissOrOccluded);
	if (numMissOrOccluded == totalOcclusionSamples)
	{
		color = vec3(1.0f, 0.0f, 0.0f);
	}
	else
	{
		color = vec3(0.0f, 1.0f, 1.0f);
	}*/
	
	// Sample a cone of directions given the vector from the isect point to the light and its radius
	vec3 isectPointToLightCenter = lightCenter - isectPoint;
	vec3 isectPointToLightCenterDir = normalize(isectPointToLightCenter);
	float isectPointToLightCenterDist = length(isectPointToLightCenter);
	float tangentDist = sqrt((isectPointToLightCenterDist * isectPointToLightCenterDist) - (lightRadius * lightRadius));
	float cosThetaIsectPointLightTangent = tangentDist / isectPointToLightCenterDist;
	float conePdf = ConePdf(cosThetaIsectPointLightTangent);
	const int numOcclusionSteps = 10;
	int totalOcclusionSamples = int(pow(numOcclusionSteps + 1, 2));
	float lightContr = 0.0f;
	for (int i = 0; i <= numOcclusionSteps; i++)
	{
		for (int j = 0; j <= numOcclusionSteps; j++)
		{
			// Sample occlusion ray direction and trace
			vec3 occlusionRayDir = SampleCone(isectPointToLightCenterDir, vec2(float(i) / float(numOcclusionSteps), float(j) / float(numOcclusionSteps)), cosThetaIsectPointLightTangent);
			Ray occlusionRay = GenerateRay(isectPoint + (isectNormal * 0.001f), occlusionRayDir);
			traceNV(scene, rayFlags, cullMask, SECONDARY_CHIT_IDX, sbtRecordStride, SECONDARY_MISS_IDX, occlusionRay.origin, tMin, occlusionRay.dir, tMax, SECONDARY_PAYLOAD_LOCATION);
			
			// Intersect spherical light
			float lightDist = SphereIntersect(lightCenter, lightRadius, occlusionRay.origin, occlusionRay.dir, tMin, tMax);
			
			// Check for intersection with geometry before an intersection with the light
			// 1) Did intersect the light
			// 2) Either didn't hit some geometry or the distance to the isect is further
			//    than the distance to the isect on the light
			if ((lightDist >= 0.0f) && (secondaryPayload.hitDist.x < 0.0f || secondaryPayload.hitDist.x >= lightDist))
			{
				lightContr += dot(isectNormal, occlusionRay.dir) / conePdf;
			}
		}
	}
	vec3 color = primaryPayload.materialColor.rgb * lightColor * (lightContr / float(totalOcclusionSamples));
	//color = vec3(lightContr / float(totalOcclusionSamples));
	
	//Store
    imageStore(resultImage, ivec2(gl_LaunchIDNV.xy), vec4(color, 1.0f));
}


















// Basic lighting data
/*vec3 lightPos = vec3(0.0f, 50.0f, 0.0f);
vec3 lightColor = vec3(1.0f, 1.0f, 1.0f);
// Intersection-Light data
vec3 isectPointToLight = lightPos - isectPoint;
vec3 isectPointToLightDir = normalize(isectPointToLight);
float isectPointToLightDist = length(isectPointToLight);

// Trace shadow rays
Ray shadowRay = GenerateRay(isectPoint + (isectNormal * 0.001f), isectPointToLightDir);
traceNV(scene, rayFlags, cullMask, SECONDARY_CHIT_IDX, sbtRecordStride, SECONDARY_MISS_IDX, shadowRay.origin, tMin, shadowRay.dir, tMax, SECONDARY_PAYLOAD_LOCATION);
    
// Check for geometry between intersection point and light
if (secondaryPayload.hitDist.x > 0.0f && secondaryPayload.hitDist.x < isectPointToLightDist)
{
 	imageStore(resultImage, ivec2(gl_LaunchIDNV.xy), vec4(0.0f, 0.0f, 0.0f, 1.0f));
   	return;
}
    
// Calculate light
float contribution = dot(isectNormal, isectPointToLightDir);
vec3 contributionColor = lightColor * contribution;
vec3 color = primaryPayload.materialColor.rgb * contributionColor;*/
